Perfecto. Preparar√© un PRD completo y detallado para tu plataforma de pedidos inteligentes para restaurantes, incluyendo backend y frontend, siguiendo arquitectura modular con NestJS, PostgreSQL, Redis Pub/Sub y WebSockets. Usaremos el SDK de MCP en TypeScript y lo conectaremos a Prisma para que la IA atienda pedidos en tiempo real.

El sistema incluir√° roles de cliente, cocinero, administrador y cajero. Incluir√© ejemplos de buenas pr√°cticas en el c√≥digo. Tambi√©n inventar√© un nombre atractivo alineado con la cultura de Rep√∫blica Dominicana.

Te avisar√© cuando el documento est√© listo para tu revisi√≥n.


# **Delicia** ‚Äì Plataforma Inteligente de Pedidos para Restaurantes

## Resumen Ejecutivo

**Delicia** (nombre temporal inspirado en la palabra *‚Äúdelicia‚Äù* para evocar sabor y destacando ‚ÄúIA‚Äù al final para *Inteligencia Artificial*) es una plataforma inteligente de gesti√≥n de pedidos dirigida a negocios de comida r√°pida y restaurantes de cualquier tama√±o, desde peque√±os puestos hasta grandes cadenas. El sistema centralizar√° el men√∫ y la toma de pedidos, asistido por una **IA conversacional** integrada que mejora la experiencia del cliente al poder responder preguntas sobre platillos, tomar pedidos mediante chat y guiar al usuario de forma natural.

La plataforma busca **optimizar la eficiencia operativa**: los pedidos de clientes se reflejan en tiempo real en un *Modo Cocina* para los cocineros, los cajeros pueden gestionar pagos y entregas, y los administradores cuentan con un **dashboard visual** para monitorear ventas y operaciones. Todo esto se desarrollar√° como un **monolito modular** con NestJS en el backend y React en el frontend, usando tecnolog√≠as modernas (PostgreSQL, Prisma, Redis, WebSockets, Tailwind, etc.) para asegurar escalabilidad y mantenimiento a largo plazo.

**Alcance:** El PRD cubre los requerimientos funcionales y t√©cnicos de la plataforma de pedidos, la integraci√≥n de la IA conversacional con Model Context Protocol, la arquitectura modular del sistema, los roles de usuario y sus flujos, consideraciones de UI/UX (incluyendo microinteracciones y estilo dominicano moderno), y ejemplos de implementaci√≥n en c√≥digo. **Quedan fuera de alcance** en esta fase las funcionalidades de promociones inteligentes y campa√±as de marketing automatizadas, las cuales se podr√°n incorporar en el futuro una vez establecida la base del sistema.

## Objetivos del Producto

* **Mejorar la Experiencia de Pedido:** Permitir a los clientes ordenar comida de forma intuitiva, ya sea navegando el men√∫ tradicionalmente o interactuando con una **IA asistente** que entienda preguntas en lenguaje natural y sugiera opciones. Esto reduce tiempos de espera y errores en pedidos, brindando un trato cercano y eficiente al estilo dominicano.
* **Unificar Operaciones para Todo Tama√±o de Negocio:** Ofrecer una soluci√≥n √∫nica que funcione tanto para un puesto de comida r√°pida como para un restaurante grande. La plataforma ser√° configurable y modular, pudiendo activarse o desactivarse m√≥dulos seg√∫n necesidades (por ejemplo, un puesto peque√±o quiz√° use solo la toma de pedidos b√°sica e interfaz de cocina, mientras un restaurante grande use todos los roles y el dashboard completo).
* **Eficiencia en Tiempo Real:** Implementar capacidades en tiempo real mediante **WebSockets** para notificar instant√°neamente nuevos pedidos y cambios de estado. El *Modo Cocina* mostrar√° √≥rdenes al momento que son ingresadas, y los clientes podr√°n recibir actualizaciones de su pedido (por ejemplo, ‚Äúen preparaci√≥n‚Äù, ‚Äúlisto para recoger‚Äù). Esto mejorar√° la coordinaci√≥n entre cocina y caja, reduciendo esperas.
* **Arquitectura Robusta y Escalable:** Construir el sistema con un **dise√±o modular limpio**, siguiendo principios SOLID y arquitectura hexagonal para mantener bajo acoplamiento. NestJS permite un c√≥digo mantenible y escalable gracias a su dise√±o modular y soporte de inyecci√≥n de dependencias. Se utilizar√° **Prisma ORM** por su excelente integraci√≥n con TypeScript y garantizando consultas seguras y eficientes en PostgreSQL. La inclusi√≥n de **Redis** permitir√° escalar la app en m√∫ltiples instancias sin perder sincronizaci√≥n de eventos en tiempo real (usando un mecanismo Pub/Sub para compartir eventos entre instancias de servidor).
* **Interfaz Atractiva y Familiar:** Desarrollar un frontend con **React + Vite** que ofrezca una experiencia r√°pida y din√°mica. Utilizaremos **Tailwind CSS** y **ShadCN UI** para crear componentes visualmente atractivos y coherentes, incorporando *microinteracciones* (animaciones sutiles al pulsar botones, transiciones al abrir men√∫s, notificaciones suaves cuando llega un pedido nuevo, etc.). La est√©tica de la UI tomar√° **inspiraci√≥n moderna dominicana**, usando colores vibrantes y motivos sutiles de la cultura (por ejemplo, paleta tropical, ilustraciones de comida local estilizada) para dar a la plataforma una identidad gr√°fica distintiva y cercana al usuario local.

## Roles de Usuario y Actores

La plataforma manejar√° **cuatro roles principales**, cada uno con su interfaz y funcionalidades adaptadas:

* **Cliente (Usuario Final):** Persona que realiza el pedido de comida. Puede navegar el men√∫ por categor√≠as, buscar platos espec√≠ficos y hacer un pedido. Alternativamente, puede entablar una **conversaci√≥n con la IA asistente** para pedir recomendaciones (‚Äú¬øQu√© me recomiendas con pollo?‚Äù) o armar su orden por chat. El cliente puede personalizar art√≠culos (ej. elegir ingredientes extra o excluir algo) y finalmente confirmar su pedido. Debe poder ver el estado de su pedido en tiempo real (ej. preparado, en camino si hubiera delivery, listo para recoger, etc.). Si el pedido no se paga por adelantado, recibir√° un c√≥digo o n√∫mero para pagar en caja.
* **Cocinero (Staff de Cocina):** Usuario encargado de preparar los pedidos. Accede al **Modo Cocina**, una vista en tiempo real que muestra la cola de pedidos entrantes con detalles relevantes: n√∫mero de orden, items solicitados con sus personalizaciones, tiempos de orden. Esta interfaz se dise√±ar√° para pantallas grandes o tablets en la cocina, con actualizaciones autom√°ticas v√≠a WebSocket. El cocinero puede cambiar el estado de cada pedido (por ejemplo, marcar como ‚ÄúEn preparaci√≥n‚Äù y luego ‚ÄúListo‚Äù) para informar al sistema. La interfaz de cocina enfatiza la **legibilidad** (texto grande, contraste alto) y notificar√° claramente nuevos pedidos (sonido o resaltado visual).
* **Cajero (Staff de Caja):** Usuario que administra pagos y entregas. En un entorno de mostrador, el cajero ver√° los pedidos pendientes de pago o entrega. Puede buscar un pedido por c√≥digo/ID, ver el total a cobrar y marcarlo como pagado. Tambi√©n puede confirmar la entrega del pedido al cliente. La interfaz del cajero ser√° sencilla, listando √≥rdenes recientes y sus estados (pagado/pendiente, entregado/pendiente). Adicionalmente, el cajero podr√≠a tener la capacidad de crear pedidos manualmente en nombre de clientes que ordenan en persona, usando la misma interfaz de cliente pero r√°pida.
* **Administrador (Gerencia):** Usuario encargado de la administraci√≥n del sistema. Tendr√° acceso a un **Dashboard administrativo** con m√©tricas en tiempo real (ventas del d√≠a, platos m√°s vendidos, tiempo promedio de preparaci√≥n, etc.) presentadas mediante gr√°ficas llamativas. El administrador puede gestionar el **men√∫** (CRUD de categor√≠as y productos, incluyendo subir fotos de platos, precios, descripciones), gestionar usuarios del sistema (crear cuentas de cajeros, cocineros, etc., con roles y permisos), y revisar el historial de pedidos. Tambi√©n podr√° configurar par√°metros generales (horarios de servicio, impuestos, etc.). La prioridad para este rol es la **visualizaci√≥n clara de datos** y controles de gesti√≥n f√°ciles de usar, manteniendo la est√©tica moderna de la plataforma.

## Funcionalidades Clave por M√≥dulo

A continuaci√≥n se detallan las principales capacidades del sistema, organizadas por √°reas funcionales:

* **1. M√≥dulo de Men√∫ y Pedidos (Frontend & Backend):**

  * **Navegaci√≥n de Men√∫:** Presentaci√≥n del men√∫ con categor√≠as (ej. Entrantes, Platos fuertes, Bebidas, Postres). Los clientes pueden explorar la carta, ver detalles de cada platillo (descripci√≥n, precio, foto) y a√±adir al carrito. El men√∫ se cargar√° desde el backend (v√≠a API REST) y puede almacenarse temporalmente en el frontend para r√°pida navegaci√≥n, con actualizaciones en tiempo real si el admin cambia algo (por ejemplo, desactivar un platillo agotado).
  * **B√∫squeda y Filtros:** Barra de b√∫squeda para encontrar platos por nombre o ingredientes, con filtrado (ej. vegetariano, picante, etc.).
  * **Pedido Convencional:** Permitir al cliente armar su pedido seleccionando items del men√∫, especificando cantidades y variaciones (ej. ‚Äúsin cebolla‚Äù, ‚Äúextra queso‚Äù). El **carrito de compra** mostrar√° el resumen de la orden antes de confirmar. Al confirmar, se env√≠a la orden al backend mediante una API POST (`/orders`). Se implementar√° validaci√≥n de stock o disponibilidad al enviar la orden.
  * **Asistente de Pedidos con IA:** Integraci√≥n de un **chatbot** en la interfaz de cliente donde el usuario puede escribir (o potencialmente hablar) de manera conversacional para hacer su pedido. La IA puede entender peticiones en lenguaje natural ‚Äì por ejemplo, *‚ÄúQuiero una hamburguesa con todo y una Coca-Cola‚Äù* ‚Äì consultar internamente el men√∫ para identificar productos mencionados, hacer preguntas de aclaraci√≥n si falta info (*‚Äú¬øDesea la hamburguesa t√©rmino medio?‚Äù*), y agregar items al pedido virtual. La conversaci√≥n fluye hasta que el usuario confirma el pedido. T√©cnicamente, esto se logra exponiendo funciones del backend (buscar items, crear pedido) como **herramientas** que la IA puede invocar v√≠a MCP (ver secci√≥n de Integraci√≥n de IA).
  * **Confirmaci√≥n de Pedido:** Una vez armado el pedido (ya sea v√≠a carrito manual o chat IA), el cliente confirma y el sistema genera un n√∫mero de pedido. Si aplica pago en l√≠nea (no cubierto en esta fase, posiblemente se paga al recoger), se indicar√° el m√©todo. El pedido confirmado dispara notificaciones: aparece en la vista de cocina y caja en tiempo real. El cliente recibe una confirmaci√≥n (en la UI del cliente o chat).

* **2. M√≥dulo de Cocina (Pedidos en Tiempo Real):**

  * **Cola de Pedidos Activos:** Interfaz de cocina mostrando una lista de pedidos pendientes de preparaci√≥n. Cada pedido se presenta en una tarjeta o fila con c√≥digo, hora de entrada, listado de platos y personalizaciones. Nuevos pedidos **aparecen autom√°ticamente** sin refrescar la p√°gina, gracias a la suscripci√≥n a eventos WebSocket. Es decir, el backend emitir√° un evento `new_order` cuando un pedido ingresa, y los clientes (navegadores en cocina) lo recibir√°n instant√°neamente para a√±adirlo a la lista. (En NestJS esto se soporta mediante un *WebSocket Gateway* usando Socket.io, junto con Redis para escalar a m√∫ltiples instancias).
  * **Actualizaci√≥n de Estado:** El cocinero puede interactuar con cada pedido para cambiar su estado. Ejemplo: bot√≥n ‚ÄúMarcar como En Preparaci√≥n‚Äù y luego ‚ÄúMarcar como Listo‚Äù. Estas acciones env√≠an eventos al backend (v√≠a WebSocket o llamadas API) que actualizan la base de datos y notifica a otras interfaces interesadas. Por ejemplo, al marcar ‚ÄúListo‚Äù, el sistema notifica al cajero (su pantalla muestra que X pedido est√° listo para entregar) y opcionalmente al cliente (si est√° viendo estado desde su dispositivo).
  * **Modo Pantalla Completa y Sonidos:** El modo cocina operar√° idealmente en pantalla completa para maximizar √°rea utilizable. Se incluir√°n **indicadores audiovisuales**: p. ej., un sonido o vibraci√≥n en la interfaz al llegar un nuevo pedido, y resaltado en amarillo por unos segundos. Asimismo, si un pedido lleva demasiado tiempo en cola, podr√≠a resaltarse (indicador de demora).
  * **Gesti√≥n de Prioridad:** Posibilidad de que el cocinero o administrador reordenen la cola (por ejemplo, priorizar un pedido atrasado). Aunque inicialmente el orden es seg√∫n llegada, el sistema debe ser capaz de soportar re-priorizaci√≥n manual o autom√°tica (esta √∫ltima podr√≠a ser una futura ‚Äúinteligencia‚Äù no incluida a√∫n).

* **3. M√≥dulo de Caja (Gesti√≥n de Pagos y Entregas):**

  * **Listado de Pedidos Pendientes de Pago:** El cajero ver√° una lista de pedidos que requieren cobro (por ejemplo, pedidos realizados in situ para pagar en efectivo). Cada entrada mostrar√° el c√≥digo de pedido, nombre del cliente (si se obtuvo), total a pagar y estado (esperando pago, pagado). El cajero puede seleccionar un pedido, ver los detalles y registrar el pago (p. ej. marcando m√©todo de pago: efectivo, tarjeta). Al registrar el pago, el estado pasa a ‚ÄúPagado‚Äù, y podr√≠a notificar a cocina que ya est√° autorizado (en caso de que se espere confirmaci√≥n de pago para empezar a preparar, aunque normalmente se prepara de inmediato).
  * **Gesti√≥n de Entregas:** Para pedidos de tipo para recoger en mostrador, el cajero ve cu√°les est√°n ‚ÄúListos para entregar‚Äù (es decir, cocina ya los marc√≥ como listos). Puede llamar al cliente (p. ej. por n√∫mero de pedido o nombre) y al entregar f√≠sicamente la comida, marca el pedido como ‚ÄúEntregado/Completado‚Äù en el sistema. Esto cerrar√° el ciclo del pedido.
  * **Generaci√≥n de Tickets o Recibos:** Posibilidad de generar un recibo impreso o digital. En esta fase se puede simplemente mostrar en pantalla para impresi√≥n del navegador. (Integraciones con impresoras t√©rmicas espec√≠ficas podr√≠an considerarse m√°s adelante).
  * **Pedidos In-situ por Cajero:** El cajero debe poder crear pedidos r√°pidos en la situaci√≥n de que un cliente llegue y ordene verbalmente. Para esto podr√≠a utilizar una versi√≥n simplificada de la interfaz de pedidos del cliente (sin chat, solo seleccionando items r√°pidamente) y confirmando para enviarlo a cocina, marc√°ndolo como pagado directamente si cobra al instante. Esto permite usar la plataforma tanto para pedidos autogestionados por el cliente como para pedidos tomados por personal.

* **4. M√≥dulo de Administraci√≥n y Dashboard:**

  * **Dashboard Anal√≠tico:** Pantalla principal para administradores con gr√°ficos y KPIs. Por ejemplo, gr√°fico de barras o pastel con ventas por categor√≠a de producto, n√∫mero de pedidos en el d√≠a vs d√≠as anteriores, horas pico de pedidos, etc. Se pueden utilizar librer√≠as como Chart.js o Recharts, integradas con React, para mostrar datos din√°micamente. La arquitectura del dashboard consumir√° endpoints del backend (posiblemente v√≠a NestJS con controladores para m√©tricas agregadas). La actualizaci√≥n de ciertas m√©tricas podr√≠a ser en vivo (usando WebSockets para contar pedidos del d√≠a en tiempo real). Visualmente, este dashboard tendr√° un estilo **‚Äúmoderno limpio‚Äù** con toques de identidad dominicana (colores, tipograf√≠as amigables) pero manteniendo la claridad.
  * **Gesti√≥n de Men√∫:** Interfaz CRUD para administrar categor√≠as e √≠tems del men√∫. El admin puede: crear nuevas categor√≠as (nombre, descripci√≥n), a√±adir platos con sus detalles (nombre, ingredientes, precio, carga de imagen). Se validar√° que todos los campos obligatorios est√©n completos y se dar√° feedback de √©xito o error con microinteracciones (ej. un modal o toast ‚ÄúPlato guardado exitosamente‚Äù). Si un plato se desactiva (ej. ingrediente agotado), al guardarlo como ‚Äúno disponible‚Äù, el cambio se transmite a los clientes en tiempo real (por ejemplo, removi√©ndolo u oscureci√©ndolo en el men√∫ de la app cliente). **Ejemplo de flujo:** el admin desde el dashboard quita el producto ‚ÄúBatido de chinola‚Äù del men√∫; al confirmar, el backend emite un evento via WebSocket que hace que cualquier cliente con el men√∫ abierto lo oculte o marque agotado.
  * **Gesti√≥n de Usuarios y Roles:** El administrador puede crear cuentas para el personal (cajeros, cocineros) asign√°ndoles roles. Podr√° restablecer contrase√±as, y desactivar/activar usuarios. La seguridad es importante: solo el admin puede manejar roles, y a su vez ciertos datos sensibles (como finanzas) podr√≠an estar ocultos a roles no admin.
  * **Configuraci√≥n General:** Opciones de negocio como horario de apertura/cierre (que podr√≠a usarse para que la IA y la app sepan si est√°n aceptando pedidos), impuestos o cargos de servicio, y potencialmente traducciones de men√∫ para modo multilenguaje (futuro). Estas configuraciones se almacenar√°n en la base de datos y el frontend las consulta para comportamientos correspondientes (por ej., no aceptar pedidos fuera de horario).

*(Nota: En esta fase inicial, **no** se incluyen funcionalidades de promociones inteligentes ni campa√±as de marketing automatizado. Tampoco se aborda la integraci√≥n con servicios de delivery externos. Estas caracter√≠sticas se dejan como ampliaciones futuras fuera del alcance actual.)*

## Flujos de Usuario Principales

A continuaci√≥n se describen los flujos de trabajo m√°s importantes desde la perspectiva de los distintos roles, resaltando c√≥mo interact√∫an con el sistema:

### 1. Flujo de Pedido de Cliente (con Asistente IA integrado)

1. **Inicio ‚Äì Exploraci√≥n del Men√∫:** El cliente ingresa a la interfaz (v√≠a app web React responsiva). Si es un kiosko en local, puede haber un modo de pantalla completa. El cliente ve la p√°gina principal con categor√≠as destacadas o promociones (p.ej. ‚ÄúCombo del D√≠a‚Äù), puede hacer scroll o clic en categor√≠as para ver opciones. Alternativamente, puede abrir el **chat de la IA** (un bot√≥n tipo ‚Äú¬øNecesitas ayuda? Preg√∫ntale a nuestro asistente‚Äù).
2. **Consulta Conversacional (Opcional):** Si usa el chat, el cliente puede escribir algo como ‚ÄúTengo mucha hambre, ¬øqu√© me recomiendas?‚Äù o ‚ÄúQuiero un sandwich y un jugo de pi√±a‚Äù. La IA (basada en MCP) procesa la solicitud: internamente llama a herramientas para obtener elementos del men√∫ que coinciden (por ejemplo, busca ‚Äúsandwich‚Äù en la base de datos) y responde con un mensaje amable. Puede decir: ‚ÄúTe sugiero nuestro **Sandwich Especial** con un jugo natural de pi√±a. ¬øTe gustar√≠a a√±adirlo al pedido?‚Äù El cliente puede continuar la conversaci√≥n (ej. ‚Äú¬øQu√© trae el sandwich?‚Äù ‚Äì la IA describir√° ingredientes; ‚ÄúS√≠, a√±√°delo‚Äù ‚Äì la IA registrar√° el pedido). Todo este flujo se mantiene natural, la IA recuerda el contexto (por ejemplo, sabe que el cliente quiere jugo de pi√±a y sandwich).
3. **Construcci√≥n del Pedido:** Ya sea v√≠a chat o manual, el cliente selecciona los productos deseados. En la UI tradicional, a√±ade varios items al carrito. Puede modificar cantidades, quitar algo, o editar (p. ej. ‚Äúsin az√∫car‚Äù en el jugo, ingresando notas o seleccionando opciones predefinidas). La app valida en frontend tambi√©n (por ejemplo, no permitir cantidades negativas, etc.).
4. **Confirmaci√≥n y Env√≠o:** El cliente revisa el resumen de su pedido en la secci√≥n ‚ÄúTu Orden‚Äù. Ve el total calculado (con impuestos si aplican). Si todo est√° correcto, pulsa ‚ÄúConfirmar Pedido‚Äù. En caso de usar IA, la IA puede decir ‚ÄúVoy a confirmar tu pedido de X, total X dinero. ¬øConfirmas?‚Äù y al decir ‚Äús√≠‚Äù procede igual. La aplicaci√≥n env√≠a la orden al backend (HTTP POST `/orders` con los datos del pedido). Se muestra al usuario una confirmaci√≥n (pantalla de agradecimiento con n√∫mero de pedido y recordatorio de pago si debe pagar en caja).
5. **Notificaciones Inmediatas:** Al recibirse el pedido en backend, este crea registros en la base de datos (orden y detalles). En paralelo, el servidor emite eventos en **Tiempo Real**: uno para la interfaz de cocina (‚Äúnuevo pedido #123‚Äù), otro para la interfaz de caja (si el pago est√° pendiente, ‚Äúpedido #123 esperando pago‚Äù). El cliente podr√≠a recibir un mensaje en la misma p√°gina o chat ‚Äú¬°Gracias! Tu pedido #123 est√° en preparaci√≥n‚Äù.
6. **Espera y Seguimiento:** El cliente espera su comida. Si est√° en un local y pagar√° en caja, se dirige a pagar mencionando su n√∫mero de pedido. El cajero lo marca pagado en el sistema. Mientras, en cocina se prepara la orden. Si el cliente permanece en la p√°gina, podr√≠a ver actualizaciones: por ejemplo, una barra de estado que avanza o mensajes del estilo ‚ÄúTu orden est√° en preparaci√≥n‚Äù (posible implementaci√≥n: el cliente abre un canal WebSocket unido a su pedido, y recibe evento cuando cocina lo marca ‚Äúlisto‚Äù).
7. **Entrega:** Cuando la cocina marca el pedido como listo, el sistema env√≠a una notificaci√≥n final al cliente: ‚ÄúTu pedido est√° listo para recoger.‚Äù El cliente muestra su n√∫mero al cajero/cocinero y recoge su comida. El cajero marca el pedido entregado. En el frontend cliente, se puede mostrar un mensaje de cierre ‚Äú¬°Buen provecho! üçΩÔ∏è‚Äù. Si el cliente continuaba en el chat, la IA podr√≠a despedirse con un mensaje cordial dominicano (‚Äú¬°Disfruta tu comida! Cualquier cosa, aqu√≠ estamos, ¬°buen provecho!‚Äù).

### 2. Flujo Interno de Preparaci√≥n y Entrega (Cocina y Caja)

1. **Pedido Entrante en Cocina:** Cuando llega un nuevo pedido, el **Orders Service** del backend emite un evento usando Redis Pub/Sub, que es captado por el **Gateway de WebSocket** de NestJS. Este gateway difunde v√≠a Socket.io el evento `order:new` a todos los clientes conectados con rol cocinero. La interfaz de cocina (abierta en un navegador/terminal en la cocina) tiene un listener para `order:new` y al recibirlo agrega la orden a la lista en pantalla, acompa√±ada de un sonido breve.
2. **Preparaci√≥n:** El cocinero ve los detalles e inicia la preparaci√≥n. Puede tocar un bot√≥n ‚ÄúEn preparaci√≥n‚Äù en la interfaz, lo que podr√≠a opcionalmente cambiar el color del pedido (indicativo) y enviar un evento `order:status` con status ‚Äúpreparing‚Äù. El sistema puede registrar timestamp de inicio. (Esta etapa es m√°s informativa; si se omite, igualmente al marcar listo se computa duraci√≥n).
3. **Pedido Listo:** Una vez terminada la preparaci√≥n, el cocinero pulsa ‚ÄúMarcar como Listo‚Äù. Esto actualiza el estado en la base de datos a ‚Äúready‚Äù. Inmediatamente, el backend emite un evento `order:ready` dirigido al cliente correspondiente (si est√° conectado, filtrado por ID de pedido) y a los cajeros. El monitor de cocina podr√≠a ahora mover este pedido a una secci√≥n ‚ÄúListos para entregar‚Äù o simplemente se√±alarlo como listo.
4. **Notificaci√≥n al Cliente:** Si el cliente est√° esperando en una zona con pantalla (o en su propio dispositivo viendo el estado), recibe la notificaci√≥n de pedido listo. En restaurantes con pagers o pantallas p√∫blicas, se podr√≠a tambi√©n reflejar ah√≠ (fuera del alcance actual). En nuestro sistema, asumimos el cliente sabe v√≠a su tel√©fono o porque el cajero lo llama.
5. **Cobro y Entrega:** El cajero verifica si el pedido ya fue pagado. Si el cliente viene a recoger y no ha pagado, realiza el cobro en ese momento (registrando en sistema). Luego entrega la comida. Finalmente, el cajero marca la orden como ‚ÄúEntregada/Completada‚Äù en su interfaz. Esto concluye el ciclo, y la orden ya no aparece en pendientes de cocina ni caja. El administrador la ver√° en historial con todos sus timestamps (entrada, listo, entregado).

### 3. Flujo de Administraci√≥n del Men√∫

1. **Login Admin:** El administrador inicia sesi√≥n en la aplicaci√≥n (habr√° un sistema de autenticaci√≥n para acceder a las secciones de admin; podr√≠a ser formulario de login separado).
2. **Acceso a Men√∫:** Navega a la secci√≥n de ‚ÄúGestionar Men√∫‚Äù. Se le presenta la lista de categor√≠as existentes y platos por categor√≠a.
3. **Agregar/Editar √çtem:** Para a√±adir un nuevo platillo, pulsa ‚ÄúNuevo Producto‚Äù, llena un formulario con nombre, descripci√≥n, precio, sube una imagen (opcional), categor√≠a asignada y disponibilidad. Al guardar, el sistema valida datos (ej. precio num√©rico, campos obligatorios). El backend (NestJS) recibe la solicitud POST para crear el item. Prisma ORM inserta el registro en PostgreSQL. El servicio de men√∫ emite un evento `menu:updated` con el nuevo item. Las interfaces de cliente (si hay alguna abierta) podr√≠an as√≠ actualizarse, pero en muchos casos bastar√° que futuras aperturas ya lo muestren. (Podemos implementar que clientes conectados escuchen eventos de men√∫ para cambios en vivo).
4. **Desactivar √çtem:** El admin puede, en vez de borrar un platillo, marcarlo ‚ÄúNo disponible‚Äù. Esto cambia una propiedad del item. Nuevamente, se emite `menu:updated` evento. Los frontends de cliente podr√≠an filtrar items no disponibles o mostrarlos atenuados con etiqueta ‚Äúagotado‚Äù. La IA asistente tambi√©n consultar√° solo items disponibles al responder.
5. **Revisar Dashboard:** El admin navega al dashboard principal para ver m√©tricas. Genera un rango de fechas o ve el d√≠a actual. El frontend hace requests GET a endpoints como `/stats/sales?date=today` o suscripciones a eventos agregados, y muestra gr√°ficos. Por ejemplo, un gr√°fico de l√≠neas comparando ventas de esta semana vs semana pasada, etc. Puede identificar qu√© platos son m√°s populares (pudiendo usarlo para futuras promociones). Todo esto se logra con consultas predefinidas en el backend (aplicando agregaciones SQL v√≠a Prisma).
6. **Administrar Personal:** El admin visita la secci√≥n de usuarios. Crea una cuenta para un nuevo cajero ingresando nombre, email y asignando rol ‚Äúcajero‚Äù. El sistema env√≠a un correo de invitaci√≥n (si configurado) o le da una contrase√±a temporal. Similar para cocineros. Puede desactivar cuentas (soft-delete o flag ‚Äúinactive‚Äù). Estas operaciones son sencillas CRUD con la tabla de usuarios/roles. NestJS usar√° mecanismos de seguridad (guards o role decorators) para asegurar solo admin acceda aqu√≠.

## Integraci√≥n de la Inteligencia Artificial (Asistente Virtual)

Una caracter√≠stica central de **Delicia** es el **asistente virtual inteligente** que ayuda a los clientes en el proceso de pedido mediante conversaci√≥n natural. A nivel t√©cnico, esta IA se implementar√° integrando un modelo de lenguaje (LLM, como GPT) con nuestro backend a trav√©s de **Model Context Protocol (MCP)**.

**¬øQu√© es MCP y por qu√© usarlo?** MCP es un protocolo abierto que permite conectar aplicaciones de lenguaje (LLMs) con fuentes de datos y herramientas externas de forma estandarizada. En esencia, define una forma segura para que nuestra aplicaci√≥n exponga ciertas funcionalidades (llamadas *tools* o herramientas) que el agente de IA puede invocar durante una conversaci√≥n. Por ejemplo, crearemos herramientas como: `getMenu(category)`, `findItem(name)`, `createOrder(items)` que la IA usar√° para consultar el men√∫ en tiempo real o registrar un pedido en la base de datos. Estas herramientas son b√°sicamente funciones de backend que el protocolo MCP hace accesibles al modelo de IA.

**Arquitectura del Agente:** Utilizaremos el SDK de MCP para TypeScript en el backend, configurando un **servidor MCP** dentro de NestJS. El flujo ser√°: cuando un cliente env√≠a un mensaje en el chat, el backend lo pasa al agente de IA (posiblemente alojado en un servicio externo tipo OpenAI/Anthropic, o local). El agente analiza la intenci√≥n, y si necesita datos del sistema (por ejemplo, el usuario pregunt√≥ ‚Äú¬øQu√© tengo en mi pedido hasta ahora?‚Äù), el agente formular√° una llamada a una de las herramientas MCP. El SDK MCP recibir√° esa solicitud, ejecutar√° la funci√≥n correspondiente (e.g., obtener items actuales en carrito) y retornar√° el resultado al agente. El agente entonces responde al usuario incorporando esos datos (‚ÄúLlevas 1 Sandwich Especial y 1 Jugo de Pi√±a. ¬øDeseas algo m√°s?‚Äù). Todo esto ocurre en segundos y de forma transparente para el usuario.

**Dise√±o Conversacional:** Definiremos *prompts* y reglas para la IA de modo que tenga la ‚Äúpersonalidad‚Äù adecuada: cordial, eficiente y con un tono local amigable. Por ejemplo, al inicio podr√≠a saludar: "*¬°Hola! Soy tu asistente de pedidos. ü§ñüç¥ ¬øEn qu√© te ayudo hoy?*" y siempre usar lenguaje respetuoso pero cercano, incluyendo dominicanismos suaves si apropiado (ej. ‚Äúclaro que s√≠, tenemos jugo de chinola riqu√≠simo‚Äù). La IA debe manejar: **consultas de men√∫** (ingredientes, recomendaciones), **toma de pedido** (a√±adir/quitar items), **consultas generales** (horarios, direcci√≥n del local ‚Äì estas se podr√≠an contestar con datos fijos configurados), y **seguimiento de orden** (estado del pedido, aunque esto √∫ltimo quiz√°s lo maneje m√°s la UI que la IA). Si el usuario formula preguntas fuera del √°mbito (por ej., algo no relacionado al restaurante), la IA redirigir√° educadamente la conversaci√≥n al tema de pedidos.

**Seguridad y Limitaciones de la IA:** Dado que la IA puede ejecutar funciones de nuestro sistema, implementaremos salvaguardas: las herramientas expuestas tendr√°n verificaciones (por ejemplo, `createOrder` solo puede ejecutarse si el usuario tiene un carrito v√°lido y no se ha creado ya un pedido; no permitiremos a la IA acceder a funciones administrativas). Adem√°s, MCP sugiere considerar las herramientas como potencial ‚Äúarbitrary code execution‚Äù y tener precauci√≥n. Restringiremos lo que la IA puede hacer ‚Äì b√°sicamente limitarla a operaciones de lectura de men√∫ y escritura de pedidos dentro de los par√°metros esperados. Cualquier respuesta final al cliente pasar√° por un filtro simple para evitar respuestas inapropiadas. En resumen, la **IA actuar√° como un agente limitado al dominio de pedidos**, orquestando las funciones disponibles pero sin acceso libre a datos sensibles m√°s all√° del men√∫ y √≥rdenes del usuario actual.

**Ejemplo Breve (Conversaci√≥n):**
Usuario: *"¬øQu√© me recomiendas de postre?"*
Asistente IA: *(llama internamente `getMenu("Postres")` para listar postres)*
IA: *"Tenemos **Bizcocho dominicano** tradicional y **Helado de guan√°bana**. El bizcocho es esponjoso con suspiros, ¬°muy popular! ¬øTe apetece uno de estos?"*
Usuario: *"Suena bien el bizcocho. Agr√©galo a mi orden."*
Asistente IA: *(invoca `createOrderItem("Bizcocho dominicano")` a√±adiendo al carrito del usuario)*
IA: *"¬°Listo! A√±ad√≠ un Bizcocho dominicano. Tu orden tiene 3 items en total. ¬øDeseas algo m√°s o lo confirmamos?"*
...
*(Obs√©rvese c√≥mo la IA usa herramientas para obtener info actualizada y tomar acciones seg√∫n lo que el usuario dice, manteniendo el contexto de la conversaci√≥n.)*

## Arquitectura T√©cnica y Dise√±o del Sistema

**Visi√≥n General:** La plataforma se implementar√° como un **monolito modular**: una √∫nica aplicaci√≥n backend NestJS que contiene m√∫ltiples m√≥dulos l√≥gicos (cada uno encapsulando controladores, servicios, entidades relacionadas a un subdominio: pedidos, men√∫, usuarios, etc.). Esta elecci√≥n facilita el desarrollo inicial y mantiene consistencia, a la vez que prepara el camino para una posible futura transici√≥n a microservicios si fuese necesario (cada m√≥dulo podr√≠a extraerse en un servicio independiente m√°s adelante). La comunicaci√≥n entre m√≥dulos dentro del monolito seguir√° principios de bajo acoplamiento ‚Äì preferentemente a trav√©s de interfaces o eventos internos en lugar de llamadas directas fuertemente acopladas, para que el c√≥digo sea mantenible y testeable.

**Stack Tecnol√≥gico Resumido:**

* **Backend:** NestJS (Node.js/TypeScript) ‚Äì Framework modular y escalable; PostgreSQL ‚Äì Base de datos relacional central; Prisma ‚Äì ORM para modelar y consultar la DB de forma segura; Redis ‚Äì Base de datos en memoria usada aqu√≠ para cachear ciertos datos y principalmente para su sistema Pub/Sub; WebSockets (Socket.io) ‚Äì canal bi-direccional para features en tiempo real (notificaciones de pedidos, chat quiz√°s).
* **Frontend:** React 18+ con Vite ‚Äì para una SPA/MPA reactiva; Tailwind CSS ‚Äì para estilos utilitarios r√°pidos y consistentes; ShadCN UI ‚Äì colecci√≥n de componentes preconstruidos estilizados con Tailwind (basados en Radix UI) que acelerar√°n la creaci√≥n de una UI coherente; TypeScript ‚Äì en frontend tambi√©n, para mantener tipados los datos que vienen del backend (ayuda a evitar errores, al igual que en backend).
* **Infraestructura & DevOps (menci√≥n breve):** Si bien inicialmente podr√≠a correr en un solo servidor, es importante contenedorizar la app (Docker) para f√°cil despliegue. PostgreSQL y Redis correr√°n como servicios separados. Con Redis habilitando escalamiento horizontal, podremos correr m√∫ltiples instancias del backend NestJS detr√°s de un balanceador si la demanda crece, sin perder la sincronizaci√≥n en los eventos de WebSocket (gracias al mecanismo de Redis que compartir√° eventos entre instancias). Autenticaci√≥n probablemente con JWT para un frontend sin estado de sesi√≥n en servidor, almacenando tokens de forma segura (httpOnly cookies o similar).

### Arquitectura Backend (NestJS Monolito Modular)

Adoptaremos una arquitectura estilo **hexagonal (Ports and Adapters)** para estructurar el backend, que calza muy bien con la filosof√≠a de NestJS. En este enfoque:

* La **l√≥gica de negocio** central (casos de uso como *"crear pedido"*, *"marcar pedido listo"*, *"consultar men√∫"*) reside en servicios de dominio que **no dependen** de detalles de infraestructura (DB, framework web). Esto nos da un n√∫cleo limpio y testeable.
* Definiremos **interfaces (ports)** para operaciones como acceso a datos (por ejemplo, un `OrderRepository` con m√©todos `save(order)` o `findPendingByKitchen()`) y para integraci√≥n con otros servicios (p.ej. un `PaymentGateway` si hubiera pagos en l√≠nea, o interfaces para notificaci√≥n push/email).
* Las implementaciones concretas de estas interfaces ser√°n los **adapters**: en nuestro caso, usaremos Prisma como adapter para la base de datos implementando los repositorios, NestJS WebSockets como adapter para notificaciones en tiempo real, etc. NestJS facilita la inyecci√≥n de dependencias, por lo que podemos inyectar, por ejemplo, `PrismaOrderRepository` en el servicio de pedidos a trav√©s de un token de interfaz, manteniendo la posibilidad de sustituirlo (por ejemplo, por un mock en tests).

**Organizaci√≥n en M√≥dulos:** Cada contexto principal ser√° un m√≥dulo de NestJS:

* `AuthModule` (autenticaci√≥n y autorizaci√≥n JWT, estrategia local, etc.),
* `UserModule` (usuarios y roles),
* `MenuModule` (categor√≠as y productos),
* `OrdersModule` (pedidos y l√≥gica de flujo de estado),
* `KitchenModule` (podr√≠a ser parte de Orders pero podr√≠a manejar sus propios gateways de WS relacionados con cocina),
* `PaymentModule` (aunque inicialmente manejamos pagos offline, lo creamos con m√≠nimo esqueleto por si luego integraciones),
* `ChatbotModule` o `AIModule` (encargado de la integraci√≥n MCP y coordinaci√≥n del agente IA),
* `NotificationsModule` (si decidimos centralizar eventos y WebSocket gateways).

Los **controladores (Controllers)** expondr√°n API REST para las funcionalidades CRUD (ej. `POST /orders`, `GET /menu`, `PUT /menu/item/:id`, etc.) y podr√≠an tambi√©n manejar algunas rutas para vistas si fuera SSR (no es el caso, nuestro frontend es separado). Adicionalmente, tendremos **Gateways de WebSocket** (NestJS permite con `@WebSocketGateway`) para gestionar las conexiones en tiempo real. Posiblemente tengamos un gateway para el canal general de pedidos, y dentro de √©l rooms o canales por rol o por pedido. Por ejemplo, el `OrdersGateway` env√≠a eventos a la sala `kitchen` o a un namespace `/kitchen` para todo lo que concierne a cocineros, y a salas espec√≠ficas de cliente (pedido) para notificar al cliente de su pedido particular.

**Ejemplo de C√≥digo ‚Äì Endpoint y Servicio (NestJS):** A modo ilustrativo, a continuaci√≥n un peque√±o ejemplo simplificado de c√≥mo lucir√≠a parte del m√≥dulo de pedidos en NestJS, siguiendo buenas pr√°cticas: definimos un **DTO** para creaci√≥n de pedido, un **Controlador** que usa un **Servicio** para la l√≥gica, y ese servicio usa Prisma a trav√©s de un **PrismaService** compartido (inyecci√≥n de dependencia):

```typescript
// orders.dto.ts - DTO de entrada para crear pedido
export class CreateOrderDto {
  customerId?: string;
  items: { productId: number; quantity: number; notes?: string }[];
  // ...otros campos como ubicacion, etc. 
}

// orders.controller.ts
import { Controller, Post, Body, UseGuards } from '@nestjs/common';
import { OrdersService } from './orders.service';
import { CreateOrderDto } from './orders.dto';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('orders')
export class OrdersController {
  constructor(private readonly ordersService: OrdersService) {}

  @UseGuards(JwtAuthGuard)  // solo usuarios autenticados (ej. cliente logueado) pueden ordenar
  @Post()
  async createOrder(@Body() createOrderDto: CreateOrderDto) {
    const order = await this.ordersService.createOrder(createOrderDto);
    return order;  // retorna el pedido creado (o al menos su id y status)
  }
}
```

```typescript
// orders.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateOrderDto } from './orders.dto';

@Injectable()
export class OrdersService {
  constructor(private prisma: PrismaService) {}

  async createOrder(dto: CreateOrderDto) {
    // L√≥gica de negocio para crear un pedido
    // Por simplicidad, creamos el pedido y sus items asociados
    const newOrder = await this.prisma.order.create({
      data: {
        customerId: dto.customerId,
        status: 'PENDING',  // status inicial
        items: {
          create: dto.items.map(item => ({
            productId: item.productId,
            quantity: item.quantity,
            notes: item.notes || '',
          })),
        },
        createdAt: new Date(),
      },
      include: { items: true },  // incluir items en el objeto retornado
    });
    // Emitir evento de nuevo pedido (usando, por ejemplo, un EventEmitter interno o gateway)
    // this.eventEmitter.emit('order.created', newOrder);
    return newOrder;
  }

  async updateOrderStatus(orderId: number, newStatus: string) {
    const updated = await this.prisma.order.update({
      where: { id: orderId },
      data: { status: newStatus, updatedAt: new Date() },
    });
    // Emitir eventos seg√∫n nuevo estado si es relevante
    // ...
    return updated;
  }
}
```

En el c√≥digo anterior, el patr√≥n a resaltar es: el **Controlador** permanece ligero, delegando al servicio; el **Servicio** maneja la interacci√≥n con Prisma (nuestro ORM) para crear registros. Se usan DTOs para validar datos de entrada. La l√≥gica de emitir eventos cuando se crea o actualiza un pedido est√° indicada (podemos usar `EventEmitter2` de NestJS para eventos internos, o invocar m√©todos de un Gateway de WS para enviar notificaciones a los clientes conectados). Esta separaci√≥n de responsabilidades facilita pruebas unitarias (podemos testear `OrdersService` aislado simulando `PrismaService`).

**Integraci√≥n de Prisma ORM:** Usaremos Prisma como ORM principal. Prisma nos permite definir el esquema de datos en `schema.prisma` con modelos para `User`, `Product`, `Order`, etc., y genera un cliente tipado para consultar la base de datos. Seg√∫n la receta oficial de NestJS, tendremos un `PrismaService` injectable que extiende de PrismaClient, manejando conexi√≥n y potencialmente middleware de logging. Cada m√≥dulo que necesite acceso a BD recibe este PrismaService. Esto centraliza la configuraci√≥n de la base de datos y evita abrir m√∫ltiples conexiones. La **ventaja de Prisma** es la seguridad de tipos y evitar inyecciones SQL, as√≠ como facilidad para migraciones. Adicionalmente, podremos aprovechar las transacciones de Prisma (por ejemplo, al crear un pedido con sus items, como es arriba, todo se hace en una llamada y se garantiza atomicidad).

**Comunicaci√≥n en Tiempo Real (WebSockets + Redis):** Como se mencion√≥, utilizaremos **Socket.io** en NestJS para la capa de WebSocket. Socket.io por defecto permite emitir eventos a todos los clientes o a ciertos canales. En nuestro dise√±o, al iniciar NestJS, configuraremos un **adapter** de Socket.io que use Redis (NestJS tiene documentaci√≥n para integrar `socket.io-redis` adapter). Esto es crucial para soportar m√∫ltiples instancias de servidor: una instancia publica un evento de nuevo pedido, Redis lo recibe y lo publica a las dem√°s instancias, as√≠ *todos* los websockets conectados reciben el evento. Desde el punto de vista del c√≥digo, una vez configurado, podemos hacer `this.server.emit('order:new', payload)` en el gateway, y el adapter se encarga de la distribuci√≥n clusterizada.

* *Ejemplo:* En el `OrdersService.createOrder` mostrado, despu√©s de crear el pedido podemos inyectar el gateway (o usar EventEmitter) para notificar:

  ```typescript
  this.ordersGateway.broadcastNewOrder(newOrder);
  ```

  Y en `OrdersGateway` implementar:

  ```typescript
  @WebSocketGateway({ namespace: '/kitchen' })
  export class OrdersGateway {
    @WebSocketServer() server: Server;
    broadcastNewOrder(order) {
      this.server.emit('order:new', order);
    }
    // ... tambi√©n m√©todos para broadcast de status updates, etc.
  }
  ```

  Con `namespace: '/kitchen'` nos aseguramos que solo los clientes conectados al namespace de cocina reciban ese evento (los cocineros). Para clientes individuales, podr√≠amos usar rooms nombradas con el id de pedido o id de usuario.

**Autenticaci√≥n y Autorizaci√≥n:** NestJS facilitar√° la implementaci√≥n de JWT Auth. Tendremos un m√≥dulo Auth con estrategia local (login con usuario/contrase√±a) que al validar emite un JWT firmado. Los clientes almacenan ese token (p. ej., en una cookie segura) y lo incluyen en cada petici√≥n subsiguiente. Para websockets, Socket.io puede enviar el token en el handshake query o headers para tambi√©n autenticar la conexi√≥n. Utilizaremos **Guards de NestJS** para proteger rutas seg√∫n rol ‚Äì por ejemplo, el controlador de admin solo accesible con rol admin, etc. Los roles se pueden manejar con un decorador custom `@Roles('admin')` m√°s un guard que chequea `req.user.role`. De esta manera, se asegura que cada rol solo acceda a sus pantallas (tambi√©n controlado en frontend con rutas protegidas). Contrase√±as de usuarios se almacenar√°n **hasheadas** (usando bcrypt).

**Manejo de Errores:** El backend contar√° con filtros de excepci√≥n globales para retornar errores formateados (Nest trae uno por defecto para HttpException). Por ejemplo, si un usuario no autorizado accede a recurso prohibido, devuelve 403 JSON apropiado; validaciones fallidas de DTO devuelven 400 con mensajes; etc. Esto ayudar√° al frontend a reaccionar (mostrar mensajes amigables al usuario final).

### Arquitectura Frontend (React + Vite)

El frontend ser√° una **SPA (Single Page Application)** construida en React, lo que brinda una experiencia fluida al usuario sin recargas completas. Gracias a Vite, tendremos tiempos de carga y desarrollo muy r√°pidos. Usaremos **componentes funcionales con Hooks** para el manejo de estado y efectos secundarios. La estructura del proyecto podr√≠a organizarse por *features* o *pages*. Ejemplo:

* Carpeta `src/pages` con componentes de p√°gina: `MenuPage.tsx`, `CheckoutPage.tsx`, `KitchenDashboard.tsx`, `AdminDashboard.tsx`, etc.
* Carpeta `src/components` para componentes reutilizables: `MenuItemCard.tsx`, `OrderList.tsx`, `ChatbotWidget.tsx`, `DashboardChart.tsx`, etc.
* Carpeta `src/context` si usamos Context API para ciertos estados globales (ej. contexto de autenticaci√≥n para conocer usuario logueado y rol en toda la app; contexto de carrito de compras para persistir la orden en proceso).
* Podr√≠amos utilizar una librer√≠a de estado global como Zustand o Redux si la complejidad crece, pero inicialmente tal vez context + hooks basten.

**Estilo y Componentes (Tailwind + ShadCN UI):** Adoptaremos Tailwind CSS para desarrollar un dise√±o responsive y consistente r√°pidamente. Tailwind nos permite aplicar clases utilitarias (p.ej. `bg-indigo-600 text-white p-4 rounded`) directamente en los elementos JSX para estilarlos. Sin embargo, para evitar exceso de clases en elementos complejos, utilizaremos componentes preconstruidos de **ShadCN UI** ‚Äì que b√°sicamente provee componentes de interfaz (botones, di√°logos, men√∫s desplegables, pesta√±as, tablas, etc.) ya estilizados con Tailwind siguiendo un dise√±o moderno y accesible. Estos componentes se pueden personalizar para que encajen con nuestra identidad visual. Por ejemplo, ShadCN nos da un componente `<Button>` ya bonito y accesible, que podemos extender con nuestras variantes de color (quiz√° un verde o naranja particular representativo de la marca dominicana que creemos).

Se definir√° un **tema de colores** Tailwind en su configuraci√≥n, posiblemente inspirado en la bandera dominicana (azul a√±il, rojo vibrante, blanco) pero adaptado a UI (tonos un poco m√°s suaves para no ser estridentes en pantalla). Tambi√©n incluiremos colores tropicales complementarios (verdes, amarillos tipo sol/pl√°tano) para acentos en gr√°ficas o alertas. La **tipograf√≠a** ser√° clara y moderna, priorizando legibilidad; se puede usar una fuente sans-serif geom√©trica o incluso alguna que tenga buena presencia en espa√±ol. Importante: internacionalizaci√≥n por ahora no es prioridad (asumimos la app en espa√±ol dominicano), pero al usar Unicode y fuentes adecuadas, caracteres especiales estar√°n bien.

**Responsive Design:** La aplicaci√≥n debe funcionar tanto en un m√≥vil/tablet (quiz√° para peque√±os puestos que usan una tablet), como en una pantalla grande (admin en computadora, o pantalla en cocina). Utilizaremos unidades fluidas y breakpoints de Tailwind para adaptar layouts. Por ejemplo, la barra lateral de admin quiz√° se muestre contra√≠da en m√≥vil, etc. El *Modo Cocina* probablemente est√© optimizado para una pantalla horizontal grande, pero haremos que al menos sea scrollable en dispositivos m√°s peque√±os si se diera el caso.

**Interacci√≥n con Backend API:** Para obtener o enviar datos (cuando no se usan websockets), utilizaremos la API REST. Podemos emplear `fetch` nativo o una librer√≠a como Axios. Gracias a TypeScript, definiremos tipos o interfaces para las respuestas (p. ej. `Order` interface matching the backend DTO) para tener auto completado y chequeos en compile time. Las llamadas se har√≠an t√≠picamente dentro de hooks (e.g., useEffect para fetch on load) or via event handlers.

**Manejo de WebSocket en Frontend:** Usaremos la librer√≠a cliente de Socket.io para conectarnos al servidor WebSocket. Al montar ciertas componentes, estableceremos la conexi√≥n y escucharemos eventos. Por ejemplo, en `KitchenDashboard.tsx` (pseudoc√≥digo):

```tsx
import { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

function KitchenDashboard() {
  const [orders, setOrders] = useState<Order[]>([]);
  useEffect(() => {
    const socket: Socket = io('<SERVER_URL>/kitchen', {
      auth: { token: localStorage.getItem('token') }  // enviar token JWT para autenticar
    });
    socket.on('order:new', (order: Order) => {
      setOrders(prev => [ ...prev, order ]); // agregar nuevo pedido a la lista
    });
    socket.on('order:update', (update: {id: number, status: string}) => {
      setOrders(prev => prev.map(o => o.id === update.id ? {...o, status: update.status} : o));
    });
    return () => { socket.disconnect(); };
  }, []);
  
  // renderizar la lista de orders...
}
```

En el fragmento anterior, establecemos conexi√≥n al namespace `/kitchen` y escuchamos dos eventos: nuevos pedidos y actualizaciones de estado. Al recibirlos, actualizamos el estado local `orders` para re-renderizar la UI con los cambios. Notar que enviamos el JWT en la conexi√≥n (`auth` option) para que el servidor valide que solo usuarios con rol cocinero entren al canal de cocina.

**Ejemplo de Componente React (UI de Item de Men√∫):** Para ilustrar el uso de Tailwind y ShadCN, imagine un componente para mostrar un platillo en la lista:

```tsx
// MenuItemCard.tsx
import { Button } from "@/components/ui/button"  // importado de ShadCN UI
import { Badge } from "@/components/ui/badge"

function MenuItemCard({ item, onAdd }) {
  return (
    <div className="bg-white shadow rounded-md p-4 flex flex-col">
      <h3 className="text-xl font-semibold mb-1">{item.name}</h3>
      <p className="text-sm text-gray-600 flex-grow">{item.description}</p>
      <div className="mt-2 flex items-center justify-between">
        <span className="text-lg font-bold">${item.price}</span>
        {item.isAvailable ? (
          <Button onClick={() => onAdd(item)} className="ml-2">A√±adir</Button>
        ) : (
          <Badge variant="destructive">Agotado</Badge>
        )}
      </div>
    </div>
  );
}
```

En este componente, usamos clases Tailwind (`bg-white`, `shadow`, `rounded-md`, etc.) para la tarjeta. Usamos un `<Button>` de ShadCN UI para el bot√≥n A√±adir (que ya viene estilizado y accesible) y un `<Badge>` para mostrar si est√° agotado. Esto demuestra c√≥mo mantenemos el c√≥digo declarativo y limpio, delegando el estilo a utilidades y componentes pre-hechos.

**Microinteracciones y Feedback Visual:** Aprovecharemos CSS transitions y peque√±as animaciones para dar fluidez. Ejemplos: cuando el usuario a√±ade un item, podr√≠amos hacer que el bot√≥n ‚ÄúA√±adir‚Äù muestre un check ‚úì por un segundo y vuelva a estado normal, indicando que se a√±adi√≥. Al abrir el chat de la IA, podr√≠a deslizarse desde un lado con una animaci√≥n. Al marcar un pedido como listo en cocina, ese pedido podr√≠a parpadear en verde suave. Estas microinteracciones aumentan la percepci√≥n de calidad. Usaremos las capacidades de Tailwind para transitions (`transition-colors`, `duration-300`, etc.) y keyframes CSS personalizados donde necesario.

**Identidad Gr√°fica Dominicana:** Buscamos que la aplicaci√≥n se sienta **moderna y local**. Esto podr√≠a lograrse incorporando sutilmente algunos elementos: por ejemplo, √≠conos personalizados inspirados en comida t√≠pica (un icono de empanada, un pote de habichuelas, etc.) para adornar categor√≠as o el splash screen. Colores vibrantes pero equilibrados (azul cer√∫leo como el mar de Punta Cana, verde hoja de palma, naranja atardecer del Malec√≥n) pueden aparecer en botones o encabezados. Cuidaremos que no distraigan de la usabilidad. Tambi√©n el tono comunicativo en textos y mensajes ser√° cercano: usando expresiones coloquiales ligeras (de acuerdo al p√∫blico objetivo dominicano) para generar empat√≠a. Todo esto sin caer en estereotipos, m√°s bien resaltando la calidez y alegr√≠a asociada a la cultura dominicana.

## Consideraciones de Escalabilidad y Mantenibilidad

* **Modularidad para Escala Futura:** Aunque es un monolito, la separaci√≥n en m√≥dulos l√≥gicos facilita asignar equipos distintos a diferentes √°reas sin pisarse, y posibilita escalar componentes espec√≠ficos. Por ejemplo, si el volumen de pedidos crece enormemente, podr√≠amos escalar horizontalmente el m√≥dulo de pedidos (replicando instancias de la app, ya que es stateless salvo websockets, los cuales manejamos con Redis). Si en un futuro se decide extraer, por ejemplo, el Chatbot como microservicio independiente, la arquitectura de puertos y adaptadores ayuda porque la l√≥gica de IA est√° aislada en `AIModule` con interfaces claras hacia el resto.
* **Redis Cache:** Adem√°s de Pub/Sub, podemos usar Redis para cachear datos frecuentemente le√≠dos pero poco cambiantes, como el men√∫ o las estad√≠sticas del d√≠a, reduciendo carga a PostgreSQL. Esto ser√° √∫til en horas pico. Implementaremos caching en capas de servicio donde tenga sentido (p. ej., cache de 1 minuto para el listado de men√∫ si muchos usuarios lo piden simult√°neo).
* **Clean Code y Contribuciones:** Fomentaremos buenas pr√°cticas de c√≥digo: linters (ESLint), formateo (Prettier), y seguimiento de convenciones de NestJS (archivos bien nombrados, m√©todos cortos y claros). Tambi√©n, cubriremos partes cr√≠ticas con **pruebas unitarias** (especialmente la l√≥gica de pedidos y las herramientas de IA) y pruebas de integraci√≥n b√°sicas (simular un flujo completo de pedido). Esto garantiza que al agregar nuevas funcionalidades (como las promociones en el futuro) no rompamos lo existente.
* **Seguridad:** Aplicaremos medidas de seguridad como sanitizaci√≥n de inputs (Nest ya ayuda con validation pipes contra data mal formada). Protegemos datos sensibles: por ejemplo, si se guardan datos de tarjetas (no contemplado ahora), se har√≠a de forma segura o delegada a terceros. Evitaremos exponer informaci√≥n de m√°s en las APIs ‚Äì por ejemplo, un cliente autenticado solo puede ver sus propios pedidos, el servidor validar√° el `userId` en cada consulta de pedidos. Tambi√©n implementaremos *rate limiting* en endpoints p√∫blicos si fuera necesario (para evitar abusos del chat por bots, etc.).
* **Logs y Monitoreo:** Instrumentaremos el backend para logging de eventos importantes (un pedido creado, error de DB, etc.) y potencialmente uso de un APM or monitoring (como Grafana/Prometheus) if deployed in production. Esto ayuda a mantener la plataforma confiable y diagnosticar problemas r√°pido.

## Plan de Implementaci√≥n y Tareas por Equipo

Para llevar a cabo el desarrollo de **Delicia**, dividiremos el trabajo entre los equipos **Backend** y **Frontend**, manteniendo sincron√≠a en los contratos (API endpoints, formatos de datos, eventos) y con iteraciones para integrar y probar funcionalidades incrementalmente. A continuaci√≥n se listan las tareas principales de cada √°rea:

### Equipo Backend (NestJS & Base de Datos)

* **Configuraci√≥n Inicial del Proyecto:** Crear la base del proyecto NestJS (usando Nest CLI), configurar el **monorepo modular** con TypeScript. Instalar dependencias clave: `@nestjs/websockets`, `socket.io`, `@nestjs/config` (para variables de entorno), `@nestjs/jwt` (auth), `prisma`. Inicializar Prisma with a PostgreSQL connection.
* **Dise√±o del Esquema DB (Prisma):** Definir el modelo de datos en `schema.prisma` incluyendo tablas: Users (campos: id, nombre, email, rol, password hash, etc.), Categories, Products, Orders, OrderItems, etc. Ejecutar migraciones para crear las tablas en la base de datos PostgreSQL.
* **Implementar M√≥dulo de Autenticaci√≥n:** Configurar JWT AuthStrategy. Crear endpoints `POST /auth/login` (devuelve token) y `POST /auth/signup` (posiblemente para registro de clientes, aunque quiz√°s se maneje sin registro). Proteger rutas posteriores con `JwtAuthGuard`. Verificar que los roles se incluyan en el token JWT para usar en autorizaci√≥n.
* **Implementar M√≥dulo de Usuarios/Roles:** CRUD de usuarios b√°sico (principalmente para que admin cree personal). Seeds iniciales: crear un usuario admin por defecto. Endpoint `GET /users/me` para que frontend obtenga perfil y rol. Guards para restringir endpoints admin.
* **Implementar M√≥dulo de Men√∫:** Endpoints REST para categor√≠as (`GET /menu/categories`, `POST /menu/categories`, etc.) y productos (`GET /menu/items`, `POST /menu/items`, `PUT /menu/items/:id`, `DELETE /menu/items/:id`). Servicios Prisma para leer/escribir. Considerar a√±adir filtrar solo disponibles en `GET /menu/items` para cliente vs admin que ve todos. Incluir validaci√≥n de DTOs (usando `class-validator`).
* **Implementar M√≥dulo de Pedidos:** Endpoints `POST /orders` (crear pedido), `GET /orders/:id` (detalle, con items y estado), quiz√°s `GET /orders` (lista filtrada por usuario o por estado para admins). L√≥gica de negocio: al crear pedido, asignar c√≥digo/numero; si soportamos multi-sucursal en futuro, incluirla. Emitir evento de nuevo pedido (integrar con WebSocket gateway). Endpoint para actualizar estado (`PUT /orders/:id/status`) que podr√≠an llamar cocina o caja (con autorizaci√≥n por rol).
* **Configurar WebSocket Gateway:** Crear clase OrdersGateway con namespace o filters por rol. Integrar `IoAdapter` de socket.io con Redis. Testear que cuando un pedido se crea, el evento llega a un cliente simulado suscrito. Similar para update de estado.
* **Integraci√≥n IA (MCP):** Montar el servidor MCP. Definir las herramientas: por ejemplo, dentro de `AIModule`, usar el SDK TS de MCP para registrar herramientas `getMenu`, `createOrder`, etc. Probablemente necesitemos definir c√≥mo el agente IA se comunica con nosotros; podr√≠a ser que actuamos como tanto cliente como servidor MCP. Investigar mejor implementaci√≥n: quiz√° ejecutar un cliente LLM (OpenAI API) que llame a nuestras tools definidas via MCP. Implementar un servicio que orquesta esto: recibe prompt del usuario, llama al agente (via SDK), espera respuesta enriquecida. *Tarea espec√≠fica:* escribir prompts iniciales y funciones en JSON schema para herramientas, y probar con un modelo (puede ser offline primero). Asegurar la seguridad (herramientas no hacen m√°s de lo debido).
* **Servicios de Notificaci√≥n (opcional):** Si tiempo permite, integrar un EventEmitter interno para manejar eventos de dominio (like `order.created`) de forma desacoplada: por ejemplo, al ocurrir, un listener env√≠a notificaci√≥n email (futuro) o logs. Esto es extra; enfoque principal son websockets.
* **Pruebas Unitarias y de Integraci√≥n (Backend):** Escribir tests para los servicios principales (OrdersService, MenuService, etc.), usando either an in-memory SQLite DB for Prisma or test transactions. Pruebas de autorizaci√≥n (que endpoints protegidos rechacen usuarios sin rol). Prueba simulada del chat IA (dado cierta entrada, se espera llame a tool X).
* **Documentaci√≥n API:** Crear documentaci√≥n de la API (quiz√° integrar Swagger en NestJS para listar endpoints, dto schema, etc. para uso interno y para que frontend consulte si duda formato).

### Equipo Frontend (React & UI/UX)

* **Setup del Proyecto React:** Inicializar proyecto con Vite + React + TypeScript. Configurar TailwindCSS (postcss, etc.) y ShadCN UI (instalar los componentes necesarios). Organizar estructura de carpetas base. Configurar router (React Router) con rutas protegidas (por rol). E.g., public routes: login, ordering interface; private routes: /kitchen, /admin, /cashier (que requieren auth & specific role).

* **Implementaci√≥n de Autenticaci√≥n UI:** Crear p√°ginas de Login y Registro (si aplica) con formularios usando componentes de formulario de ShadCN (inputs, etc.). Conectar al endpoint `/auth/login` para obtener JWT; guardar token (posiblemente en localStorage o cookie). Gestionar estado global de auth (context or simple state in App). Redirigir usuarios a la p√°gina adecuada seg√∫n rol tras login (ej. admin->/admin, cocinero->/kitchen, cajero->/cashier, cliente->/menu).

* **Pantalla de Men√∫ y Pedido (Cliente):** Desarrollar la p√°gina principal de pedido del cliente. Esto incluye: mostrar categor√≠as y lista de productos. Implementar el componente `MenuItemCard` para cada plato (como el ejemplo de c√≥digo). A√±adir funcionalidad al bot√≥n ‚ÄúA√±adir‚Äù: actualiza estado del carrito global (puede usar Context `CartContext`). Mostrar un resumen del carrito en un sidebar o modal, con bot√≥n ‚ÄúConfirmar Pedido‚Äù. Al confirmar, llamar al API `/orders` con los datos; manejar respuesta (navegar a p√°gina de confirmaci√≥n/seguimiento).

* **Chatbot UI (Cliente):** Implementar un widget de chat flotante o embebido. Por simplicidad, podr√≠a ser un componente que aparece sobre la UI de men√∫. Este componente `ChatbotWidget` tendr√° una ventana de chat (lista de mensajes) y un input para texto. Necesita manejar estado de la conversaci√≥n (lista de {sender, message}). Al enviar un mensaje, llamar a un endpoint del backend `/ai/chat` (por ejemplo) que gestione la interacci√≥n con la IA (este endpoint en backend usar√≠a el agente MCP para obtener respuesta). Alternativamente, se podr√≠a mantener la conexi√≥n por WebSocket para chat, pero quiz√° REST polling es m√°s simple al inicio. Decidir e implementar la comunicaci√≥n: si via REST, cada mensaje produce una request y la respuesta se agrega al chat; si via WS, abrir una conexi√≥n en este componente al namespace chat, enviar evento y escuchar respuesta. En cualquier caso, formatear la respuesta (puede incluir texto, opciones sugeridas). Asegurar scroll al √∫ltimo mensaje, etc. A√±adir peque√±as animaciones: por ej., mientras espera respuesta, mostrar "Escribiendo..." con tres puntitos animados.

* **Vista de Confirmaci√≥n y Tracking:** Tras confirmar pedido, mostrar n√∫mero de pedido e instrucciones (‚ÄúAc√©rcate a caja para pagar‚Äù o similar). Si se decide implementar tracking en cliente, esta p√°gina se suscribe v√≠a WebSocket a eventos `order:update` filtrados a su pedido. El backend podr√≠a emit√≠rselos uni√©ndolo a una sala con su pedidoId cuando hizo el pedido (necesitar√≠amos en OrdersGateway, cuando un cliente crea pedido, a√±adir su socket a room `order_<id>`). Simplificadamente, se puede hacer polling en frontend cada X segundos al endpoint `/orders/:id` para ver si status cambi√≥. Pero WebSocket es m√°s en tiempo real; implementar el escucha si es viable.

* **Interfaz de Cocina (KitchenDashboard.tsx):** Crear la p√°gina para cocineros. Inicialmente cargar la lista de pedidos pendientes (GET `/orders?status=PENDING` por ejemplo). Mostrar en un componente `OrderCard` informaci√≥n condensada. Implementar la l√≥gica de conexi√≥n WebSocket (como ejemplificado antes) para recibir nuevos pedidos y actualizaciones. A√±adir controles: un bot√≥n en cada OrderCard ‚ÄúMarcar Listo‚Äù (que har√° PUT `/orders/:id/status` a ‚ÄúREADY‚Äù; podemos optim√≠sticamente actualizar UI de inmediato y el WS despu√©s lo confirmar√°). Considerar confirmaci√≥n modal para evitar clics accidentales. UI/UX: usar colores de estado (ej. PENDING = amarillo, READY = verde).

* **Interfaz de Caja (CashierDashboard.tsx):** Similar a cocina: lista de pedidos que requieren atenci√≥n del cajero. Quiz√° filtrar por `status != COMPLETED`. Actualizar v√≠a WS tambi√©n. Mostrar claramente cuales necesitan cobro (status PENDING && not paid flag) vs cuales est√°n listos para entregar (READY status). Para cobro: un bot√≥n ‚ÄúMarcar Pagado‚Äù en pedidos no pagados (realiza PUT `/orders/:id/pay` o podr√≠amos fold payment into status ‚ÄúPAID‚Äù if combine). Para entrega: bot√≥n ‚ÄúEntregado‚Äù (PUT `/orders/:id/status` -> COMPLETED). Podr√≠an estar en secciones separadas ‚ÄúPor cobrar‚Äù y ‚ÄúPara entregar‚Äù. Tras marcar completado, remover de lista.

* **Interfaz de Admin (AdminPanel):** Implementar varias sub-p√°ginas o secciones:

  * **Dashboard:** con tarjetas res√∫men (total ventas hoy, pedidos hoy, etc.) y gr√°ficas. Empezar con una o dos gr√°ficas simples (ej. usando Chart.js React wrapper). Datos los obtenemos de endpoints `/stats` que el backend deber√° proveer. Si esos no est√°n listos, se pueden mockear temporalmente.
  * **Gesti√≥n de Men√∫:** una tabla o lista de productos editables. Usar componentes de tabla de ShadCN UI si hay (o simple HTML table styled). Cada fila con acciones editar/eliminar. Un formulario para nuevo producto (puede ser modal emergente o p√°gina aparte). Para cargar datos: GET `/menu/items` (admin ver√≠a todos). Para editar: abrir modal con formulario, al guardar hacer PUT. Manejar la respuesta actualizando la lista local sin requerir refetch completo (o simplemente refetch tras operaci√≥n, dado pocos datos no es costoso).
  * **Gesti√≥n de Usuarios:** listar empleados, con bot√≥n ‚ÄúAgregar usuario‚Äù (form para email, rol, etc.). Llamar API correspondiente. Permitir desactivar usuarios con toggle.
  * **Configuraciones:** uno o dos campos editables (horario, nombre restaurante) para demostrar capacidad, aunque su uso en otras partes sea limitado al inicio.

* **Estilos y Pulido:** Ajustar CSS para que todas las p√°ginas tengan un dise√±o cohesivo. Testear en distintos tama√±os de pantalla. A√±adir logos o √≠conos temporales (un logo ‚ÄúDelicia‚Äù temporal con un emoji de comida quiz√°s) solo para demostrar la marca. Implementar los textos finales, asegur√°ndose que el tono de comunicaci√≥n est√© presente (por ejemplo mensajes de √©xito: ‚Äú¬°Listo! Los cambios se han guardado.‚Äù en vez de solo ‚ÄúSuccess‚Äù). Revisar accesibilidad: colores contrastantes, alt en im√°genes.

* **Pruebas en Frontend:** Realizar pruebas manuales exhaustivas en el flujo completo (pedido -> cocina -> caja -> finalizado). Si es posible, escribir algunos unit tests para componentes puros (por ejemplo, l√≥gica de a√±adir items al carrito, se espera que sume cantidades correctamente). Tambi√©n probar la integraci√≥n con backend simulado (usando un servidor de prueba o mocks) para asegurarse de manejo de estados de conexi√≥n (ej. WS desconectado muestra alerta, etc.).

* **Iteraci√≥n de Feedback:** Hacer una demo interna de la aplicaci√≥n, recopilar feedback de usabilidad (por ejemplo, ¬øentiende el usuario promedio que puede usar el chat para pedir? ¬ødeber√≠amos resaltar ese feature con un tooltip?). Incorporar mejoras UI/UX seg√∫n el tiempo restante.

Finalmente, ambos equipos coordinar√°n para **integraci√≥n final**: conectar el frontend con el backend desplegado en entorno de pruebas, y garantizar que todas las piezas (pedidos, IA, realtime, etc.) funcionan en conjunto de forma fluida. Cada tarea estar√° asociada a entregables tangibles (por ejemplo, *‚ÄúEndpoint X funcionando‚Äù*, *‚ÄúComponente Y implementado‚Äù*, *‚Äúchatbot responde recomendaciones‚Äù*), lo que permitir√° seguir el progreso y ajustar prioridades si fuese necesario. Con esta hoja de ruta, **Delicia** estar√° encaminada a ser una plataforma innovadora que combine tecnolog√≠a de punta (IA, tiempo real) con un entendimiento cultural local, proporcionando una soluci√≥n de pedidos eficiente y encantadora para Rep√∫blica Dominicana.

**Fuentes:** Las decisiones t√©cnicas se fundamentaron en buenas pr√°cticas y referencias de la industria, por ejemplo la separaci√≥n por capas y uso de arquitectura hexagonal para mantener bajo acoplamiento, el uso de Prisma ORM por su seguridad de tipos y soporte robusto a PostgreSQL, la adopci√≥n de Redis Pub/Sub para garantizar la entrega de eventos en tiempo real en entornos escalables, y la integraci√≥n de MCP (Model Context Protocol) para dotar al agente de IA de capacidades conectadas al contexto de la aplicaci√≥n. Estas referencias respaldan la viabilidad t√©cnica del enfoque propuesto y servir√°n de gu√≠a durante la implementaci√≥n detallada.
